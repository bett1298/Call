<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DateLink â€” Call Room</title>
  <style>
    body {
      font-family: 'Poppins', sans-serif;
      background: #fff0f5;
      text-align: center;
      margin: 0;
      padding: 20px;
    }
    h1 {
      color: #ff4f87;
    }
    .video-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 20px 0;
      flex-wrap: wrap;
    }
    video {
      width: 45%;
      min-width: 300px;
      border-radius: 12px;
      background: #000;
      border: 2px solid #ff4f87;
    }
    .controls {
      margin: 20px 0;
    }
    button {
      background: #ff4f87;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      margin: 5px;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      transition: background 0.3s;
    }
    button:hover {
      background: #e03e6d;
    }
    button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }
    input {
      padding: 12px;
      width: 250px;
      border-radius: 8px;
      border: 2px solid #ff4f87;
      margin: 5px;
      font-size: 16px;
    }
    #status {
      margin: 20px 0;
      padding: 10px;
      border-radius: 8px;
      font-weight: bold;
      min-height: 24px;
    }
    .status-connecting {
      background: #fffacd;
      color: #856404;
    }
    .status-connected {
      background: #d4edda;
      color: #155724;
    }
    .status-error {
      background: #f8d7da;
      color: #721c24;
    }
  </style>
</head>
<body>
  <h1>ðŸŽ¥ DateLink â€” Call Room</h1>
  
  <div class="video-container">
    <div>
      <h3>You</h3>
      <video id="localVideo" autoplay playsinline muted></video>
    </div>
    <div>
      <h3>Partner</h3>
      <video id="remoteVideo" autoplay playsinline></video>
    </div>
  </div>

  <div class="controls">
    <button id="createBtn">Create Call</button>
    <input id="callIdInput" placeholder="Enter Call ID to join" />
    <button id="joinBtn">Join Call</button>
    <button id="hangupBtn" style="background: #dc3545;">Hang Up</button>
  </div>

  <p id="status">Ready to connect...</p>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
    import {
      getFirestore, collection, doc, setDoc, getDoc,
      onSnapshot, updateDoc, deleteDoc
    } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

    // --- Firebase Config ---
    const firebaseConfig = {
      apiKey: "AIzaSyD9dwHPDTJr1-mFXPW_JZnVS-JyZ6BNMgU",
      authDomain: "smart-waste-66279.firebaseapp.com",
      projectId: "smart-waste-66279",
      storageBucket: "smart-waste-66279.appspot.com",
      messagingSenderId: "619099585646",
      appId: "1:619099585646:web:b193d2a9fc13347d88ba7f"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
const servers = {
  iceServers: [
    { urls: ['stun:stun.l.google.com:19302'] },
    {
      urls: 'turn:relay1.expressturn.com:3478',
      username: 'efree',
      credential: 'efreepass'
    }
  ]
};
    

    let pc = null;
    let callDoc = null;
    let isCaller = false;

    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const createBtn = document.getElementById('createBtn');
    const joinBtn = document.getElementById('joinBtn');
    const hangupBtn = document.getElementById('hangupBtn');
    const callIdInput = document.getElementById('callIdInput');
    const status = document.getElementById('status');

    let localStream = null;
    let remoteStream = null;

    // âœ… Initialize media
    async function initMedia() {
      try {
        if (localStream) {
          return localStream;
        }
        
        localStream = await navigator.mediaDevices.getUserMedia({ 
          video: { width: 1280, height: 720 },
          audio: true 
        });
        localVideo.srcObject = localStream;
        console.log("âœ… Local media ready");
        return localStream;
      } catch (err) {
        console.error("Media access error:", err);
        updateStatus("Error: Please allow camera and microphone access.", "error");
        throw err;
      }
    }

    // âœ… Create new peer connection
    function createPeerConnection() {
      const newPC = new RTCPeerConnection(servers);
      
      // Add local tracks
      if (localStream) {
        localStream.getTracks().forEach(track => {
          newPC.addTrack(track, localStream);
        });
      }

      // Handle remote stream
      newPC.ontrack = event => {
        console.log("ðŸŽ¥ Received remote tracks:", event.streams);
        if (event.streams && event.streams[0]) {
          remoteStream = event.streams[0];
          remoteVideo.srcObject = remoteStream;
          updateStatus("Connected! You can see each other now.", "connected");
        }
      };

      // Connection state handling
      newPC.onconnectionstatechange = () => {
        console.log("Connection state:", newPC.connectionState);
        switch(newPC.connectionState) {
          case "connected":
            updateStatus("Connected!", "connected");
            break;
          case "disconnected":
          case "failed":
            updateStatus("Connection lost", "error");
            break;
          case "connecting":
            updateStatus("Connecting...", "connecting");
            break;
        }
      };

      newPC.oniceconnectionstatechange = () => {
        console.log("ICE connection state:", newPC.iceConnectionState);
      };

      return newPC;
    }

    // âœ… Update status
    function updateStatus(message, type = "") {
      status.textContent = message;
      status.className = type ? `status-${type}` : '';
    }

    // âœ… Clean up function
    async function hangUp() {
      updateStatus("Ending call...");
      
      if (pc) {
        pc.close();
        pc = null;
      }
      
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      
      if (callDoc) {
        try {
          await deleteDoc(callDoc);
        } catch (error) {
          console.log("Call document already deleted");
        }
        callDoc = null;
      }
      
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;
      updateStatus("Call ended. Ready to connect again.");
      isCaller = false;
    }

    // --- Create Call ---
    createBtn.onclick = async () => {
      try {
        await initMedia();
        pc = createPeerConnection();
        isCaller = true;

        callDoc = doc(collection(db, "calls"));
        const offerCandidates = collection(callDoc, "offerCandidates");
        const answerCandidates = collection(callDoc, "answerCandidates");

        callIdInput.value = callDoc.id;
        updateStatus("Share this Call ID: " + callDoc.id, "connecting");

        // Save offer ICE candidates
        pc.onicecandidate = async (event) => {
          if (event.candidate) {
            console.log("ðŸ“¡ New ICE candidate (offer):", event.candidate);
            await setDoc(doc(offerCandidates), event.candidate.toJSON());
          }
        };

        // Create and set local offer
        const offerDescription = await pc.createOffer();
        await pc.setLocalDescription(offerDescription);

        const offer = {
          sdp: offerDescription.sdp,
          type: offerDescription.type,
          createdAt: new Date()
        };
        await setDoc(callDoc, { offer });

        // Listen for answer
        onSnapshot(callDoc, async (snapshot) => {
          const data = snapshot.data();
          if (!data) return;

          if (data.answer && pc.signalingState !== "stable") {
            console.log("ðŸ“© Received answer:", data.answer);
            const answerDescription = new RTCSessionDescription(data.answer);
            await pc.setRemoteDescription(answerDescription);
          }

          if (data.hangup) {
            updateStatus("Partner left the call", "error");
            hangUp();
          }
        });

        // Listen for remote ICE candidates
        onSnapshot(answerCandidates, (snapshot) => {
          snapshot.docChanges().forEach(async (change) => {
            if (change.type === "added") {
              const candidate = new RTCIceCandidate(change.doc.data());
              console.log("ðŸŒ Adding remote ICE candidate:", candidate);
              try {
                await pc.addIceCandidate(candidate);
              } catch (error) {
                console.error("Error adding ICE candidate:", error);
              }
            }
          });
        });

      } catch (error) {
        console.error("Error creating call:", error);
        updateStatus("Error creating call: " + error.message, "error");
      }
    };

    // --- Join Call ---
    joinBtn.onclick = async () => {
      try {
        const callId = callIdInput.value.trim();
        if (!callId) {
          alert("Please enter a Call ID to join.");
          return;
        }

        await initMedia();
        pc = createPeerConnection();
        isCaller = false;

        callDoc = doc(db, "calls", callId);
        const offerCandidates = collection(callDoc, "offerCandidates");
        const answerCandidates = collection(callDoc, "answerCandidates");

        updateStatus("Joining call...", "connecting");

        // Save answer ICE candidates
        pc.onicecandidate = async (event) => {
          if (event.candidate) {
            console.log("ðŸ“¡ New ICE candidate (answer):", event.candidate);
            await setDoc(doc(answerCandidates), event.candidate.toJSON());
          }
        };

        // Get the offer and create answer
        const callSnapshot = await getDoc(callDoc);
        if (!callSnapshot.exists()) {
          alert("Call not found. Please check the Call ID.");
          return;
        }

        const callData = callSnapshot.data();
        if (!callData?.offer) {
          alert("Invalid call data.");
          return;
        }

        await pc.setRemoteDescription(new RTCSessionDescription(callData.offer));

        const answerDescription = await pc.createAnswer();
        await pc.setLocalDescription(answerDescription);

        const answer = {
          type: answerDescription.type,
          sdp: answerDescription.sdp,
          answeredAt: new Date()
        };
        await updateDoc(callDoc, { answer });

        // Listen for ICE candidates from caller
        onSnapshot(offerCandidates, (snapshot) => {
          snapshot.docChanges().forEach(async (change) => {
            if (change.type === "added") {
              const candidate = new RTCIceCandidate(change.doc.data());
              console.log("ðŸŒ Adding remote ICE candidate:", candidate);
              try {
                await pc.addIceCandidate(candidate);
              } catch (error) {
                console.error("Error adding ICE candidate:", error);
              }
            }
          });
        });

        // Listen for hangup
        onSnapshot(callDoc, (snapshot) => {
          const data = snapshot.data();
          if (data?.hangup) {
            updateStatus("Partner left the call", "error");
            hangUp();
          }
        });

      } catch (error) {
        console.error("Error joining call:", error);
        updateStatus("Error joining call: " + error.message, "error");
      }
    };

    // --- Hang Up ---
    hangupBtn.onclick = async () => {
      if (callDoc && pc) {
        try {
          await updateDoc(callDoc, { hangup: true });
        } catch (error) {
          console.log("Error sending hangup signal:", error);
        }
      }
      await hangUp();
    };

    // Clean up on page unload
    window.addEventListener('beforeunload', hangUp);
  </script>
</body>
</html>