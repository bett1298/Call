<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DateLink â€” Call Room</title>
  <style>
    body {
      font-family: 'Poppins', sans-serif;
      background: #fff0f5;
      text-align: center;
      margin: 0;
      padding: 20px;
    }
    h1 {
      color: #ff4f87;
    }
    .video-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 20px 0;
      flex-wrap: wrap;
    }
    video {
      width: 45%;
      min-width: 300px;
      border-radius: 12px;
      background: #000;
      border: 2px solid #ff4f87;
    }
    .controls {
      margin: 20px 0;
    }
    button {
      background: #ff4f87;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      margin: 5px;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      transition: background 0.3s;
    }
    button:hover {
      background: #e03e6d;
    }
    button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }
    input {
      padding: 12px;
      width: 250px;
      border-radius: 8px;
      border: 2px solid #ff4f87;
      margin: 5px;
      font-size: 16px;
    }
    #status {
      margin: 20px 0;
      padding: 10px;
      border-radius: 8px;
      font-weight: bold;
      min-height: 24px;
    }
    .status-connecting {
      background: #fffacd;
      color: #856404;
    }
    .status-connected {
      background: #d4edda;
      color: #155724;
    }
    .status-error {
      background: #f8d7da;
      color: #721c24;
    }
    .connection-info {
      background: #e9ecef;
      padding: 10px;
      border-radius: 8px;
      margin: 10px 0;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <h1>ðŸŽ¥ DateLink â€” Call Room</h1>
  
  <div class="video-container">
    <div>
      <h3>You</h3>
      <video id="localVideo" autoplay playsinline muted></video>
    </div>
    <div>
      <h3>Partner</h3>
      <video id="remoteVideo" autoplay playsinline></video>
    </div>
  </div>

  <div class="connection-info" id="connectionInfo">
    Connection: Checking...
  </div>

  <div class="controls">
    <button id="createBtn">Create Call</button>
    <input id="callIdInput" placeholder="Enter Call ID to join" />
    <button id="joinBtn">Join Call</button>
    <button id="hangupBtn" style="background: #dc3545;">Hang Up</button>
  </div>

  <p id="status">Ready to connect...</p>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
    import {
      getFirestore, collection, doc, setDoc, getDoc,
      onSnapshot, updateDoc, deleteDoc
    } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

    // --- Firebase Config ---
    const firebaseConfig = {
      apiKey: "AIzaSyD9dwHPDTJr1-mFXPW_JZnVS-JyZ6BNMgU",
      authDomain: "smart-waste-66279.firebaseapp.com",
      projectId: "smart-waste-66279",
      storageBucket: "smart-waste-66279.appspot.com",
      messagingSenderId: "619099585646",
      appId: "1:619099585646:web:b193d2a9fc13347d88ba7f"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // âœ… Enhanced ICE servers with TURN for cross-network connectivity
    const servers = {
      iceServers: [
        // Free STUN servers
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:stun3.l.google.com:19302' },
        { urls: 'stun:stun4.l.google.com:19302' },
        
        // Free TURN servers (these may have limits)
        {
          urls: 'turn:openrelay.metered.ca:80',
          username: 'openrelayproject',
          credential: 'openrelayproject'
        },
        {
          urls: 'turn:openrelay.metered.ca:443',
          username: 'openrelayproject',
          credential: 'openrelayproject'
        },
        {
          urls: 'turn:openrelay.metered.ca:443?transport=tcp',
          username: 'openrelayproject',
          credential: 'openrelayproject'
        }
      ],
      iceCandidatePoolSize: 10,
      iceTransportPolicy: 'all' // Try both relay and host candidates
    };

    let pc = null;
    let callDoc = null;
    let isCaller = false;
    let iceConnectionCheck = null;

    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const createBtn = document.getElementById('createBtn');
    const joinBtn = document.getElementById('joinBtn');
    const hangupBtn = document.getElementById('hangupBtn');
    const callIdInput = document.getElementById('callIdInput');
    const status = document.getElementById('status');
    const connectionInfo = document.getElementById('connectionInfo');

    let localStream = null;
    let remoteStream = null;

    // âœ… Initialize media with better error handling
    async function initMedia() {
      try {
        if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
        }
        
        localStream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            width: { ideal: 1280 },
            height: { ideal: 720 },
            frameRate: { ideal: 30 }
          },
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });
        
        localVideo.srcObject = localStream;
        console.log("âœ… Local media ready");
        return localStream;
      } catch (err) {
        console.error("Media access error:", err);
        updateStatus("Error: Please allow camera and microphone access.", "error");
        throw err;
      }
    }

    // âœ… Create new peer connection with enhanced settings
    function createPeerConnection() {
      const newPC = new RTCPeerConnection(servers);
      
      // Enhanced connection state monitoring
      newPC.onconnectionstatechange = () => {
        const state = newPC.connectionState;
        console.log("Connection state:", state);
        updateConnectionInfo(state);
        
        switch(state) {
          case "connected":
            updateStatus("Connected! You can see each other now.", "connected");
            break;
          case "disconnected":
            updateStatus("Connection unstable - trying to reconnect...", "connecting");
            break;
          case "failed":
            updateStatus("Connection failed - please try again", "error");
            setTimeout(() => {
              if (newPC.connectionState === 'failed') {
                hangUp();
              }
            }, 2000);
            break;
          case "connecting":
            updateStatus("Connecting... This may take a moment", "connecting");
            break;
        }
      };

      // ICE connection state
      newPC.oniceconnectionstatechange = () => {
        const iceState = newPC.iceConnectionState;
        console.log("ICE connection state:", iceState);
        
        if (iceState === 'failed') {
          console.log("ICE failed, may need TURN server");
        }
      };

      // ICE gathering state
      newPC.onicegatheringstatechange = () => {
        console.log("ICE gathering state:", newPC.iceGatheringState);
      };

      // Handle remote stream
      newPC.ontrack = event => {
        console.log("ðŸŽ¥ Received remote tracks:", event.streams);
        if (event.streams && event.streams[0]) {
          remoteStream = event.streams[0];
          remoteVideo.srcObject = remoteStream;
          
          // Listen for when remote video starts playing
          remoteVideo.onloadedmetadata = () => {
            console.log("Remote video metadata loaded");
          };
          
          remoteVideo.onplay = () => {
            console.log("Remote video started playing");
            updateStatus("Connected! Video is streaming.", "connected");
          };
        }
      };

      // ICE candidate logging
      newPC.onicecandidate = (event) => {
        if (event.candidate) {
          const candidate = event.candidate;
          console.log("ICE candidate type:", candidate.type);
          console.log("ICE candidate protocol:", candidate.protocol);
          console.log("ICE candidate address:", candidate.address);
        } else {
          console.log("ICE gathering complete");
        }
      };

      // Add local tracks
      if (localStream) {
        localStream.getTracks().forEach(track => {
          newPC.addTrack(track, localStream);
          console.log(`Added local track: ${track.kind}`);
        });
      }

      return newPC;
    }

    // âœ… Update connection info display
    function updateConnectionInfo(state) {
      connectionInfo.textContent = `Connection: ${state}`;
      connectionInfo.className = `connection-info ${
        state === 'connected' ? 'status-connected' : 
        state === 'connecting' ? 'status-connecting' : 
        'status-error'
      }`;
    }

    // âœ… Update status
    function updateStatus(message, type = "") {
      status.textContent = message;
      status.className = type ? `status-${type}` : '';
    }

    // âœ… Clean up function
    async function hangUp() {
      updateStatus("Ending call...");
      updateConnectionInfo("disconnected");
      
      if (iceConnectionCheck) {
        clearTimeout(iceConnectionCheck);
        iceConnectionCheck = null;
      }
      
      if (pc) {
        pc.close();
        pc = null;
      }
      
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      
      if (callDoc) {
        try {
          await deleteDoc(callDoc);
        } catch (error) {
          console.log("Call document already deleted");
        }
        callDoc = null;
      }
      
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;
      updateStatus("Call ended. Ready to connect again.");
      isCaller = false;
    }

    // âœ… Wait for ICE gathering to complete
    function waitForICEGathering(pc, timeout = 10000) {
      return new Promise((resolve, reject) => {
        if (pc.iceGatheringState === 'complete') {
          resolve();
          return;
        }
        
        const checkInterval = setInterval(() => {
          if (pc.iceGatheringState === 'complete') {
            clearInterval(checkInterval);
            clearTimeout(timeoutId);
            resolve();
          }
        }, 100);
        
        const timeoutId = setTimeout(() => {
          clearInterval(checkInterval);
          console.warn("ICE gathering timeout - proceeding anyway");
          resolve(); // Continue even if ICE gathering times out
        }, timeout);
      });
    }

    // --- Create Call ---
    createBtn.onclick = async () => {
      try {
        await initMedia();
        pc = createPeerConnection();
        isCaller = true;

        callDoc = doc(collection(db, "calls"));
        const offerCandidates = collection(callDoc, "offerCandidates");
        const answerCandidates = collection(callDoc, "answerCandidates");

        callIdInput.value = callDoc.id;
        updateStatus("Creating call... Share this ID: " + callDoc.id, "connecting");

        // Save offer ICE candidates
        pc.onicecandidate = async (event) => {
          if (event.candidate) {
            try {
              await setDoc(doc(offerCandidates), event.candidate.toJSON());
            } catch (error) {
              console.error("Error saving ICE candidate:", error);
            }
          }
        };

        // Create and set local offer
        const offerDescription = await pc.createOffer({
          offerToReceiveAudio: true,
          offerToReceiveVideo: true
        });
        await pc.setLocalDescription(offerDescription);

        // Wait for ICE candidates to be gathered
        await waitForICEGathering(pc);

        const offer = {
          sdp: pc.localDescription.sdp,
          type: pc.localDescription.type,
          createdAt: new Date()
        };
        await setDoc(callDoc, { offer });

        console.log("âœ… Offer created and saved");

        // Listen for answer
        onSnapshot(callDoc, async (snapshot) => {
          const data = snapshot.data();
          if (!data) return;

          if (data.answer && pc.signalingState === "have-local-offer") {
            console.log("ðŸ“© Received answer");
            const answerDescription = new RTCSessionDescription(data.answer);
            await pc.setRemoteDescription(answerDescription);
          }

          if (data.hangup) {
            updateStatus("Partner left the call", "error");
            hangUp();
          }
        });

        // Listen for remote ICE candidates
        onSnapshot(answerCandidates, (snapshot) => {
          snapshot.docChanges().forEach(async (change) => {
            if (change.type === "added") {
              const candidateData = change.doc.data();
              if (pc.remoteDescription) {
                const candidate = new RTCIceCandidate(candidateData);
                try {
                  await pc.addIceCandidate(candidate);
                  console.log("âœ… Added remote ICE candidate");
                } catch (error) {
                  console.error("Error adding ICE candidate:", error);
                }
              }
            }
          });
        });

      } catch (error) {
        console.error("Error creating call:", error);
        updateStatus("Error creating call: " + error.message, "error");
      }
    };

    // --- Join Call ---
    joinBtn.onclick = async () => {
      try {
        const callId = callIdInput.value.trim();
        if (!callId) {
          alert("Please enter a Call ID to join.");
          return;
        }

        await initMedia();
        pc = createPeerConnection();
        isCaller = false;

        callDoc = doc(db, "calls", callId);
        const offerCandidates = collection(callDoc, "offerCandidates");
        const answerCandidates = collection(callDoc, "answerCandidates");

        updateStatus("Joining call...", "connecting");

        // Save answer ICE candidates
        pc.onicecandidate = async (event) => {
          if (event.candidate) {
            try {
              await setDoc(doc(answerCandidates), event.candidate.toJSON());
            } catch (error) {
              console.error("Error saving ICE candidate:", error);
            }
          }
        };

        // Get the offer and create answer
        const callSnapshot = await getDoc(callDoc);
        if (!callSnapshot.exists()) {
          alert("Call not found. Please check the Call ID.");
          return;
        }

        const callData = callSnapshot.data();
        if (!callData?.offer) {
          alert("Invalid call data.");
          return;
        }

        console.log("Setting remote description...");
        await pc.setRemoteDescription(new RTCSessionDescription(callData.offer));

        const answerDescription = await pc.createAnswer({
          offerToReceiveAudio: true,
          offerToReceiveVideo: true
        });
        await pc.setLocalDescription(answerDescription);

        // Wait for ICE candidates to be gathered
        await waitForICEGathering(pc);

        const answer = {
          type: pc.localDescription.type,
          sdp: pc.localDescription.sdp,
          answeredAt: new Date()
        };
        await updateDoc(callDoc, { answer });

        console.log("âœ… Answer created and sent");

        // Listen for ICE candidates from caller
        onSnapshot(offerCandidates, (snapshot) => {
          snapshot.docChanges().forEach(async (change) => {
            if (change.type === "added") {
              const candidateData = change.doc.data();
              if (pc.remoteDescription) {
                const candidate = new RTCIceCandidate(candidateData);
                try {
                  await pc.addIceCandidate(candidate);
                  console.log("âœ… Added remote ICE candidate");
                } catch (error) {
                  console.error("Error adding ICE candidate:", error);
                }
              }
            }
          });
        });

        // Listen for hangup
        onSnapshot(callDoc, (snapshot) => {
          const data = snapshot.data();
          if (data?.hangup) {
            updateStatus("Partner left the call", "error");
            hangUp();
          }
        });

      } catch (error) {
        console.error("Error joining call:", error);
        updateStatus("Error joining call: " + error.message, "error");
      }
    };

    // --- Hang Up ---
    hangupBtn.onclick = async () => {
      if (callDoc && pc) {
        try {
          await updateDoc(callDoc, { hangup: true });
        } catch (error) {
          console.log("Error sending hangup signal:", error);
        }
      }
      await hangUp();
    };

    // Clean up on page unload
    window.addEventListener('beforeunload', hangUp);
  </script>
</body>
</html>