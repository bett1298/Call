<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DateLink â€” Call Room</title>
  <style>
    body {
      font-family: 'Poppins', sans-serif;
      background: #fff0f5;
      text-align: center;
      margin: 0;
      padding: 20px;
    }
    h1 { color: #ff4f87; }
    .video-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 20px 0;
      flex-wrap: wrap;
    }
    video {
      width: 45%;
      min-width: 300px;
      border-radius: 12px;
      background: #000;
      border: 2px solid #ff4f87;
    }
    .controls { margin: 20px 0; }
    button {
      background: #ff4f87;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      margin: 5px;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      transition: background 0.3s;
    }
    button:hover { background: #e03e6d; }
    input {
      padding: 12px;
      width: 250px;
      border-radius: 8px;
      border: 2px solid #ff4f87;
      margin: 5px;
      font-size: 16px;
    }
    #status {
      margin: 20px 0;
      padding: 10px;
      border-radius: 8px;
      font-weight: bold;
      min-height: 24px;
    }
    .status-connecting { background: #fffacd; color: #856404; }
    .status-connected { background: #d4edda; color: #155724; }
    .status-error { background: #f8d7da; color: #721c24; }
  </style>
</head>
<body>
  <h1>ðŸŽ¥ DateLink â€” Call Room</h1>

  <div class="video-container">
    <div>
      <h3>You</h3>
      <video id="localVideo" autoplay playsinline muted></video>
    </div>
    <div>
      <h3>Partner</h3>
      <video id="remoteVideo" autoplay playsinline></video>
    </div>
  </div>

  <div class="controls">
    <button id="createBtn">Create Call</button>
    <input id="callIdInput" placeholder="Enter Call ID to join" />
    <button id="joinBtn">Join Call</button>
    <button id="hangupBtn" style="background: #dc3545;">Hang Up</button>
  </div>

  <p id="status">Ready to connect...</p>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
    import {
      getFirestore, collection, doc, setDoc, getDoc,
      onSnapshot, updateDoc, deleteDoc
    } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

    // --- Firebase Config ---
    const firebaseConfig = {
      apiKey: "AIzaSyD9dwHPDTJr1-mFXPW_JZnVS-JyZ6BNMgU",
      authDomain: "smart-waste-66279.firebaseapp.com",
      projectId: "smart-waste-66279",
      storageBucket: "smart-waste-66279.appspot.com",
      messagingSenderId: "619099585646",
      appId: "1:619099585646:web:b193d2a9fc13347d88ba7f"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // --- Add STUN + TURN (relay) servers ---
    const servers = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        {
          urls: "turn:relay1.expressturn.com:3478",
          username: "efree",
          credential: "efree123"
        }
      ],
      iceCandidatePoolSize: 10
    };

    let pc = null;
    let callDoc = null;
    let isCaller = false;

    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const createBtn = document.getElementById('createBtn');
    const joinBtn = document.getElementById('joinBtn');
    const hangupBtn = document.getElementById('hangupBtn');
    const callIdInput = document.getElementById('callIdInput');
    const status = document.getElementById('status');

    let localStream = null;
    let remoteStream = new MediaStream();

    async function initMedia() {
      try {
        if (!localStream) {
          localStream = await navigator.mediaDevices.getUserMedia({
            video: { width: 1280, height: 720 },
            audio: true
          });
          localVideo.srcObject = localStream;
          console.log("âœ… Local media ready");
        }
      } catch (err) {
        updateStatus("âŒ Please allow camera & microphone access.", "error");
        throw err;
      }
    }

    function createPeerConnection() {
      const newPC = new RTCPeerConnection(servers);

      localStream.getTracks().forEach(track => newPC.addTrack(track, localStream));
      newPC.ontrack = event => {
        event.streams[0].getTracks().forEach(track => remoteStream.addTrack(track));
        remoteVideo.srcObject = remoteStream;
        updateStatus("Connected! ðŸŽ‰", "connected");
      };

      newPC.oniceconnectionstatechange = () => {
        console.log("ICE State:", newPC.iceConnectionState);
        if (newPC.iceConnectionState === "disconnected" || newPC.iceConnectionState === "failed") {
          updateStatus("âš ï¸ Connection lost.", "error");
        }
      };

      return newPC;
    }

    function updateStatus(message, type = "") {
      status.textContent = message;
      status.className = type ? `status-${type}` : '';
    }

    async function hangUp() {
      updateStatus("Ending call...");
      if (pc) {
        pc.close();
        pc = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      if (callDoc) {
        try { await deleteDoc(callDoc); } catch (e) {}
        callDoc = null;
      }
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;
      updateStatus("Call ended. Ready again.");
    }

    // --- Create Call ---
    createBtn.onclick = async () => {
      await initMedia();
      pc = createPeerConnection();
      isCaller = true;

      callDoc = doc(collection(db, "calls"));
      const offerCandidates = collection(callDoc, "offerCandidates");
      const answerCandidates = collection(callDoc, "answerCandidates");
      callIdInput.value = callDoc.id;

      updateStatus("Share this Call ID: " + callDoc.id, "connecting");

      pc.onicecandidate = async event => {
        if (event.candidate) {
          await setDoc(doc(offerCandidates), event.candidate.toJSON());
        }
      };

      const offerDescription = await pc.createOffer();
      await pc.setLocalDescription(offerDescription);

      const offer = { sdp: offerDescription.sdp, type: offerDescription.type };
      await setDoc(callDoc, { offer });

      onSnapshot(callDoc, async snapshot => {
        const data = snapshot.data();
        if (!pc.currentRemoteDescription && data?.answer) {
          await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
        }
        if (data?.hangup) hangUp();
      });

      onSnapshot(answerCandidates, snapshot => {
        snapshot.docChanges().forEach(change => {
          if (change.type === "added") {
            const candidate = new RTCIceCandidate(change.doc.data());
            pc.addIceCandidate(candidate).catch(console.error);
          }
        });
      });
    };

    // --- Join Call ---
    joinBtn.onclick = async () => {
      const callId = callIdInput.value.trim();
      if (!callId) return alert("Enter a Call ID first.");

      await initMedia();
      pc = createPeerConnection();
      isCaller = false;

      callDoc = doc(db, "calls", callId);
      const offerCandidates = collection(callDoc, "offerCandidates");
      const answerCandidates = collection(callDoc, "answerCandidates");

      updateStatus("Joining call...", "connecting");

      pc.onicecandidate = async event => {
        if (event.candidate) {
          await setDoc(doc(answerCandidates), event.candidate.toJSON());
        }
      };

      const callSnapshot = await getDoc(callDoc);
      if (!callSnapshot.exists()) return alert("âŒ Call not found.");

      const callData = callSnapshot.data();
      await pc.setRemoteDescription(new RTCSessionDescription(callData.offer));

      const answerDescription = await pc.createAnswer();
      await pc.setLocalDescription(answerDescription);

      const answer = { type: answerDescription.type, sdp: answerDescription.sdp };
      await updateDoc(callDoc, { answer });

      onSnapshot(offerCandidates, snapshot => {
        snapshot.docChanges().forEach(change => {
          if (change.type === "added") {
            const candidate = new RTCIceCandidate(change.doc.data());
            pc.addIceCandidate(candidate).catch(console.error);
          }
        });
      });

      onSnapshot(callDoc, snapshot => {
        const data = snapshot.data();
        if (data?.hangup) hangUp();
      });
    };

    hangupBtn.onclick = async () => {
      if (callDoc) await updateDoc(callDoc, { hangup: true });
      await hangUp();
    };

    window.addEventListener("beforeunload", hangUp);
  </script>
</body>
</html>